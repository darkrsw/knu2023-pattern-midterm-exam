from app_analyzer import collectAccessMapFromPath

test_input_path = "./commons-lang/"

def test_app_analyzer():
    expected = {'SystemUtils': {"getEnvironmentVariable['String', 'String']": set(), 'getHostName[]': {'IS_OS_WINDOWS'}, 'getJavaHome[]': set(), 'getJavaIoTmpDir[]': set(), "getJavaVersionMatches['String']": {'JAVA_SPECIFICATION_VERSION'}, "getOsMatches['String', 'String']": {'OS_NAME', 'OS_VERSION'}, "getOsMatchesName['String']": {'OS_NAME'}, 'getUserDir[]': set(), 'getUserHome[]': set(), 'getUserName[]': set(), "getUserName['String']": {'USER_NAME'}, 'isJavaAwtHeadless[]': {'JAVA_AWT_HEADLESS'}, "isJavaVersionAtLeast['JavaVersion']": set(), "isJavaVersionAtMost['JavaVersion']": set(), "isJavaVersionMatch['String', 'String']": set(), "isOSMatch['String', 'String', 'String', 'String']": set(), "isOSNameMatch['String', 'String']": set(), "isOSVersionMatch['String', 'String']": set()}, 'RandomStringUtils': {'random[]': set(), "random['int']": set(), "random['int', 'boolean', 'boolean']": set(), "random['int', 'char']": set(), "random['int', 'int', 'int', 'boolean', 'boolean']": set(), "random['int', 'int', 'int', 'boolean', 'boolean', 'char']": set(), "random['int', 'int', 'int', 'boolean', 'boolean', 'char', 'Random']": set(), "random['int', 'String']": set(), "randomAlphabetic['int']": set(), "randomAlphabetic['int', 'int']": set(), "randomAlphanumeric['int']": set(), "randomAlphanumeric['int', 'int']": set(), "randomAscii['int']": set(), "randomAscii['int', 'int']": set(), "randomGraph['int']": set(), "randomGraph['int', 'int']": set(), "randomNumeric['int']": set(), "randomNumeric['int', 'int']": set(), "randomPrint['int']": set(), "randomPrint['int', 'int']": set()}, 'ClassLoaderUtils': {'getSystemURLs[]': set(), 'getThreadURLs[]': set(), "getURLs['ClassLoader']": {'EMPTY_URL_ARRAY'}, "toString['ClassLoader']": set(), "toString['URLClassLoader']": set()}, 'CharSequenceUtils': {"checkLaterThan1['CharSequence', 'CharSequence', 'int', 'int']": set(), "indexOf['CharSequence', 'CharSequence', 'int']": set(), "indexOf['CharSequence', 'int', 'int']": {'NOT_FOUND'}, "lastIndexOf['CharSequence', 'CharSequence', 'int']": {'TO_STRING_LIMIT', 'NOT_FOUND'}, "lastIndexOf['CharSequence', 'int', 'int']": {'NOT_FOUND'}, "regionMatches['CharSequence', 'boolean', 'int', 'CharSequence', 'int', 'int']": set(), "subSequence['CharSequence', 'int']": set(), "toCharArray['CharSequence']": set()}, 'ArchUtils': {'init[]': set(), 'init_Aarch_64Bit[]': set(), 'init_X86_32Bit[]': set(), 'init_X86_64Bit[]': set(), 'init_IA64_32Bit[]': set(), 'init_IA64_64Bit[]': set(), 'init_PPC_32Bit[]': set(), 'init_PPC_64Bit[]': set(), "addProcessor['String', 'Processor']": set(), "addProcessors['Processor', 'String']": set(), 'getProcessor[]': set(), "getProcessor['String']": set()}, 'CharUtils': {"toCharacterObject['char']": set(), "toCharacterObject['String']": set(), "toChar['Character']": set(), "toChar['Character', 'char']": set(), "toChar['String']": set(), "toChar['String', 'char']": set(), "toIntValue['char']": set(), "toIntValue['char', 'int']": set(), "toIntValue['Character']": set(), "toIntValue['Character', 'int']": set(), "toString['char']": {'CHAR_STRING_ARRAY'}, "toString['Character']": set(), "unicodeEscaped['char']": {'HEX_DIGITS'}, "unicodeEscaped['Character']": set(), "isAscii['char']": set(), "isAsciiPrintable['char']": set(), "isAsciiControl['char']": set(), "isAsciiAlpha['char']": set(), "isAsciiAlphaUpper['char']": set(), "isAsciiAlphaLower['char']": set(), "isAsciiNumeric['char']": set(), "isAsciiAlphanumeric['char']": set(), "compare['char', 'char']": set()}, 'RandomUtils': {'nextBoolean[]': set(), "nextBytes['int']": set(), 'nextDouble[]': set(), "nextDouble['double', 'double']": set(), 'nextFloat[]': set(), "nextFloat['float', 'float']": set(), 'nextInt[]': set(), "nextInt['int', 'int']": set(), 'nextLong[]': set(), "nextLong['long']": set(), "nextLong['long', 'long']": set(), 'random[]': set()}, 'RegExUtils': {"dotAll['String']": set(), "dotAllMatcher['String', 'String']": set(), "removeAll['String', 'Pattern']": set(), "removeAll['String', 'String']": set(), "removeFirst['String', 'Pattern']": set(), "removeFirst['String', 'String']": set(), "removePattern['String', 'String']": set(), "replaceAll['String', 'Pattern', 'String']": set(), "replaceAll['String', 'String', 'String']": set(), "replaceFirst['String', 'Pattern', 'String']": set(), "replaceFirst['String', 'String', 'String']": set(), "replacePattern['String', 'String', 'String']": set()}, 'AnnotationUtils': {"getShortClassName['Class']": set(), "appendDetail['StringBuffer', 'String', 'Object']": set(), "equals['Annotation', 'Annotation']": set(), "hashCode['Annotation']": set(), "toString['Annotation']": {'TO_STRING_STYLE'}, "isValidAnnotationMemberType['Class']": set(), "hashMember['String', 'Object']": set(), "memberEquals['Class', 'Object', 'Object']": set(), "arrayMemberEquals['Class', 'Object', 'Object']": set(), "annotationArrayMemberEquals['Annotation', 'Annotation']": set(), "arrayMemberHash['Class', 'Object']": set()}, 'BooleanUtils': {"and['boolean']": set(), "and['Boolean']": {'TRUE', 'FALSE'}, 'booleanValues[]': {'TRUE', 'FALSE'}, "compare['boolean', 'boolean']": set(), "forEach['Consumer']": set(), "isFalse['Boolean']": set(), "isNotFalse['Boolean']": set(), "isNotTrue['Boolean']": set(), "isTrue['Boolean']": set(), "negate['Boolean']": {'TRUE', 'FALSE'}, "oneHot['boolean']": set(), "oneHot['Boolean']": set(), "or['boolean']": set(), "or['Boolean']": {'TRUE', 'FALSE'}, 'primitiveValues[]': set(), "toBoolean['Boolean']": set(), "toBoolean['int']": set(), "toBoolean['int', 'int', 'int']": set(), "toBoolean['Integer', 'Integer', 'Integer']": set(), "toBoolean['String']": {'TRUE'}, "toBoolean['String', 'String', 'String']": set(), "toBooleanDefaultIfNull['Boolean', 'boolean']": set(), "toBooleanObject['int']": {'TRUE', 'FALSE'}, "toBooleanObject['int', 'int', 'int', 'int']": {'TRUE', 'FALSE'}, "toBooleanObject['Integer']": {'TRUE', 'FALSE'}, "toBooleanObject['Integer', 'Integer', 'Integer', 'Integer']": {'TRUE', 'FALSE'}, "toBooleanObject['String']": {'TRUE', 'FALSE'}, "toBooleanObject['String', 'String', 'String', 'String']": {'TRUE', 'FALSE'}, "toInteger['boolean']": set(), "toInteger['boolean', 'int', 'int']": set(), "toInteger['Boolean', 'int', 'int', 'int']": set(), "toIntegerObject['boolean']": set(), "toIntegerObject['boolean', 'Integer', 'Integer']": set(), "toIntegerObject['Boolean']": set(), "toIntegerObject['Boolean', 'Integer', 'Integer', 'Integer']": set(), "toString['boolean', 'String', 'String']": set(), "toString['Boolean', 'String', 'String', 'String']": set(), "toStringOnOff['boolean']": {'OFF', 'ON'}, "toStringOnOff['Boolean']": {'OFF', 'ON'}, "toStringTrueFalse['boolean']": {'TRUE', 'FALSE'}, "toStringTrueFalse['Boolean']": {'TRUE', 'FALSE'}, "toStringYesNo['boolean']": {'YES', 'NO'}, "toStringYesNo['Boolean']": {'YES', 'NO'}, 'values[]': {'BOOLEAN_LIST'}, "xor['boolean']": set(), "xor['Boolean']": {'TRUE', 'FALSE'}}, 'ClassPathUtils': {"packageToPath['String']": set(), "pathToPackage['String']": set(), "toFullyQualifiedName['Class', 'String']": set(), "toFullyQualifiedName['Package', 'String']": set(), "toFullyQualifiedPath['Class', 'String']": set(), "toFullyQualifiedPath['Package', 'String']": set()}, 'EnumUtils': {"asEnum['Class']": {'ENUM_CLASS_MUST_BE_DEFINED', 'S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE'}, "checkBitVectorable['Class']": {'CANNOT_STORE_S_S_VALUES_IN_S_BITS'}, "generateBitVector['Class', 'E']": set(), "generateBitVector['Class', 'Iterable']": {'NULL_ELEMENTS_NOT_PERMITTED'}, "generateBitVectors['Class', 'E']": set(), "generateBitVectors['Class', 'Iterable']": {'NULL_ELEMENTS_NOT_PERMITTED'}, "getEnum['Class', 'String']": set(), "getEnum['Class', 'String', 'E']": set(), "getEnumIgnoreCase['Class', 'String']": set(), "getEnumIgnoreCase['Class', 'String', 'E']": set(), "getEnumList['Class']": set(), "getEnumMap['Class']": set(), "getEnumMap['Class', 'Function']": set(), "getEnumSystemProperty['Class', 'String', 'E']": set(), "getFirstEnumIgnoreCase['Class', 'String', 'Function', 'E']": set(), "isValidEnum['Class', 'String']": set(), "isValidEnumIgnoreCase['Class', 'String']": set(), "processBitVector['Class', 'long']": set(), "processBitVectors['Class', 'long']": set()}, 'CharSetUtils': {"containsAny['String', 'String']": set(), "count['String', 'String']": set(), "deepEmpty['String']": set(), "delete['String', 'String']": set(), "keep['String', 'String']": set(), "modify['String', 'String', 'boolean']": set(), "squeeze['String', 'String']": set()}}

    assert expected == collectAccessMapFromPath(test_input_path)
