from app_analyzer import collectAccessMapFromPath

test_input_path = "./commons-lang/"
test_input_path2 = "./viritin/"
test_input_path3 = "./orika"
test_input_path4 = "./randoop"
test_input_path5 = "./lightcouch"

def test1_commonslang_with_answer1():
    expected = {'SystemUtils': {"getEnvironmentVariable['String', 'String']": set(), 'getHostName[]': {'IS_OS_WINDOWS'}, 'getJavaHome[]': set(), 'getJavaIoTmpDir[]': set(), "getJavaVersionMatches['String']": {'JAVA_SPECIFICATION_VERSION'}, "getOsMatches['String', 'String']": {'OS_NAME', 'OS_VERSION'}, "getOsMatchesName['String']": {'OS_NAME'}, 'getUserDir[]': set(), 'getUserHome[]': set(), 'getUserName[]': set(), "getUserName['String']": {'USER_NAME'}, 'isJavaAwtHeadless[]': {'JAVA_AWT_HEADLESS'}, "isJavaVersionAtLeast['JavaVersion']": set(), "isJavaVersionAtMost['JavaVersion']": set(), "isJavaVersionMatch['String', 'String']": set(), "isOSMatch['String', 'String', 'String', 'String']": set(), "isOSNameMatch['String', 'String']": set(), "isOSVersionMatch['String', 'String']": set()}, 'RandomStringUtils': {'random[]': set(), "random['int']": set(), "random['int', 'boolean', 'boolean']": set(), "random['int', 'char']": set(), "random['int', 'int', 'int', 'boolean', 'boolean']": set(), "random['int', 'int', 'int', 'boolean', 'boolean', 'char']": set(), "random['int', 'int', 'int', 'boolean', 'boolean', 'char', 'Random']": set(), "random['int', 'String']": set(), "randomAlphabetic['int']": set(), "randomAlphabetic['int', 'int']": set(), "randomAlphanumeric['int']": set(), "randomAlphanumeric['int', 'int']": set(), "randomAscii['int']": set(), "randomAscii['int', 'int']": set(), "randomGraph['int']": set(), "randomGraph['int', 'int']": set(), "randomNumeric['int']": set(), "randomNumeric['int', 'int']": set(), "randomPrint['int']": set(), "randomPrint['int', 'int']": set()}, 'ClassLoaderUtils': {'getSystemURLs[]': set(), 'getThreadURLs[]': set(), "getURLs['ClassLoader']": {'EMPTY_URL_ARRAY'}, "toString['ClassLoader']": set(), "toString['URLClassLoader']": set()}, 'CharSequenceUtils': {"checkLaterThan1['CharSequence', 'CharSequence', 'int', 'int']": set(), "indexOf['CharSequence', 'CharSequence', 'int']": set(), "indexOf['CharSequence', 'int', 'int']": {'NOT_FOUND'}, "lastIndexOf['CharSequence', 'CharSequence', 'int']": {'TO_STRING_LIMIT', 'NOT_FOUND'}, "lastIndexOf['CharSequence', 'int', 'int']": {'NOT_FOUND'}, "regionMatches['CharSequence', 'boolean', 'int', 'CharSequence', 'int', 'int']": set(), "subSequence['CharSequence', 'int']": set(), "toCharArray['CharSequence']": set()}, 'ArchUtils': {'init[]': set(), 'init_Aarch_64Bit[]': set(), 'init_X86_32Bit[]': set(), 'init_X86_64Bit[]': set(), 'init_IA64_32Bit[]': set(), 'init_IA64_64Bit[]': set(), 'init_PPC_32Bit[]': set(), 'init_PPC_64Bit[]': set(), "addProcessor['String', 'Processor']": set(), "addProcessors['Processor', 'String']": set(), 'getProcessor[]': set(), "getProcessor['String']": set()}, 'CharUtils': {"toCharacterObject['char']": set(), "toCharacterObject['String']": set(), "toChar['Character']": set(), "toChar['Character', 'char']": set(), "toChar['String']": set(), "toChar['String', 'char']": set(), "toIntValue['char']": set(), "toIntValue['char', 'int']": set(), "toIntValue['Character']": set(), "toIntValue['Character', 'int']": set(), "toString['char']": {'CHAR_STRING_ARRAY'}, "toString['Character']": set(), "unicodeEscaped['char']": {'HEX_DIGITS'}, "unicodeEscaped['Character']": set(), "isAscii['char']": set(), "isAsciiPrintable['char']": set(), "isAsciiControl['char']": set(), "isAsciiAlpha['char']": set(), "isAsciiAlphaUpper['char']": set(), "isAsciiAlphaLower['char']": set(), "isAsciiNumeric['char']": set(), "isAsciiAlphanumeric['char']": set(), "compare['char', 'char']": set()}, 'RandomUtils': {'nextBoolean[]': set(), "nextBytes['int']": set(), 'nextDouble[]': set(), "nextDouble['double', 'double']": set(), 'nextFloat[]': set(), "nextFloat['float', 'float']": set(), 'nextInt[]': set(), "nextInt['int', 'int']": set(), 'nextLong[]': set(), "nextLong['long']": set(), "nextLong['long', 'long']": set(), 'random[]': set()}, 'RegExUtils': {"dotAll['String']": set(), "dotAllMatcher['String', 'String']": set(), "removeAll['String', 'Pattern']": set(), "removeAll['String', 'String']": set(), "removeFirst['String', 'Pattern']": set(), "removeFirst['String', 'String']": set(), "removePattern['String', 'String']": set(), "replaceAll['String', 'Pattern', 'String']": set(), "replaceAll['String', 'String', 'String']": set(), "replaceFirst['String', 'Pattern', 'String']": set(), "replaceFirst['String', 'String', 'String']": set(), "replacePattern['String', 'String', 'String']": set()}, 'AnnotationUtils': {"getShortClassName['Class']": set(), "appendDetail['StringBuffer', 'String', 'Object']": set(), "equals['Annotation', 'Annotation']": set(), "hashCode['Annotation']": set(), "toString['Annotation']": {'TO_STRING_STYLE'}, "isValidAnnotationMemberType['Class']": set(), "hashMember['String', 'Object']": set(), "memberEquals['Class', 'Object', 'Object']": set(), "arrayMemberEquals['Class', 'Object', 'Object']": set(), "annotationArrayMemberEquals['Annotation', 'Annotation']": set(), "arrayMemberHash['Class', 'Object']": set()}, 'BooleanUtils': {"and['boolean']": set(), "and['Boolean']": {'TRUE', 'FALSE'}, 'booleanValues[]': {'TRUE', 'FALSE'}, "compare['boolean', 'boolean']": set(), "forEach['Consumer']": set(), "isFalse['Boolean']": set(), "isNotFalse['Boolean']": set(), "isNotTrue['Boolean']": set(), "isTrue['Boolean']": set(), "negate['Boolean']": {'TRUE', 'FALSE'}, "oneHot['boolean']": set(), "oneHot['Boolean']": set(), "or['boolean']": set(), "or['Boolean']": {'TRUE', 'FALSE'}, 'primitiveValues[]': set(), "toBoolean['Boolean']": set(), "toBoolean['int']": set(), "toBoolean['int', 'int', 'int']": set(), "toBoolean['Integer', 'Integer', 'Integer']": set(), "toBoolean['String']": {'TRUE'}, "toBoolean['String', 'String', 'String']": set(), "toBooleanDefaultIfNull['Boolean', 'boolean']": set(), "toBooleanObject['int']": {'TRUE', 'FALSE'}, "toBooleanObject['int', 'int', 'int', 'int']": {'TRUE', 'FALSE'}, "toBooleanObject['Integer']": {'TRUE', 'FALSE'}, "toBooleanObject['Integer', 'Integer', 'Integer', 'Integer']": {'TRUE', 'FALSE'}, "toBooleanObject['String']": {'TRUE', 'FALSE'}, "toBooleanObject['String', 'String', 'String', 'String']": {'TRUE', 'FALSE'}, "toInteger['boolean']": set(), "toInteger['boolean', 'int', 'int']": set(), "toInteger['Boolean', 'int', 'int', 'int']": set(), "toIntegerObject['boolean']": set(), "toIntegerObject['boolean', 'Integer', 'Integer']": set(), "toIntegerObject['Boolean']": set(), "toIntegerObject['Boolean', 'Integer', 'Integer', 'Integer']": set(), "toString['boolean', 'String', 'String']": set(), "toString['Boolean', 'String', 'String', 'String']": set(), "toStringOnOff['boolean']": {'OFF', 'ON'}, "toStringOnOff['Boolean']": {'OFF', 'ON'}, "toStringTrueFalse['boolean']": {'TRUE', 'FALSE'}, "toStringTrueFalse['Boolean']": {'TRUE', 'FALSE'}, "toStringYesNo['boolean']": {'YES', 'NO'}, "toStringYesNo['Boolean']": {'YES', 'NO'}, 'values[]': {'BOOLEAN_LIST'}, "xor['boolean']": set(), "xor['Boolean']": {'TRUE', 'FALSE'}}, 'ClassPathUtils': {"packageToPath['String']": set(), "pathToPackage['String']": set(), "toFullyQualifiedName['Class', 'String']": set(), "toFullyQualifiedName['Package', 'String']": set(), "toFullyQualifiedPath['Class', 'String']": set(), "toFullyQualifiedPath['Package', 'String']": set()}, 'EnumUtils': {"asEnum['Class']": {'ENUM_CLASS_MUST_BE_DEFINED', 'S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE'}, "checkBitVectorable['Class']": {'CANNOT_STORE_S_S_VALUES_IN_S_BITS'}, "generateBitVector['Class', 'E']": set(), "generateBitVector['Class', 'Iterable']": {'NULL_ELEMENTS_NOT_PERMITTED'}, "generateBitVectors['Class', 'E']": set(), "generateBitVectors['Class', 'Iterable']": {'NULL_ELEMENTS_NOT_PERMITTED'}, "getEnum['Class', 'String']": set(), "getEnum['Class', 'String', 'E']": set(), "getEnumIgnoreCase['Class', 'String']": set(), "getEnumIgnoreCase['Class', 'String', 'E']": set(), "getEnumList['Class']": set(), "getEnumMap['Class']": set(), "getEnumMap['Class', 'Function']": set(), "getEnumSystemProperty['Class', 'String', 'E']": set(), "getFirstEnumIgnoreCase['Class', 'String', 'Function', 'E']": set(), "isValidEnum['Class', 'String']": set(), "isValidEnumIgnoreCase['Class', 'String']": set(), "processBitVector['Class', 'long']": set(), "processBitVectors['Class', 'long']": set()}, 'CharSetUtils': {"containsAny['String', 'String']": set(), "count['String', 'String']": set(), "deepEmpty['String']": set(), "delete['String', 'String']": set(), "keep['String', 'String']": set(), "modify['String', 'String', 'boolean']": set(), "squeeze['String', 'String']": set()}}
    assert expected == collectAccessMapFromPath(test_input_path)

def test2_viritin_with_answer1():
    expected = {'LazyList': {"findPageFromCache['int']": {'pageIndex'}, 'loadPreviousPage[]': {'maxPages', 'pageSize', 'pageIndex'}, 'loadNextPage[]': {'maxPages', 'pageSize', 'pageIndex'}, "findEntities['int']": set(), 'size[]': {'cachedSize'}, 'getMaxPages[]': {'maxPages'}, "setMaxPages['int']": {'maxPages'}, "get['int']": {'index', 'maxPages', 'pageSize', 'pageIndex'}, "initCacheFormPage['int']": {'pageSize', 'pageIndex'}, 'getIndexCache[]': {'indexCache'}, "indexOf['Object']": {'pageSize', 'pageIndex'}, "contains['Object']": {'pages'}, "subList['int', 'int']": {'pageSize', 'maxPages'}, 'iterator[]': {'index', 'size'}, 'hasNext[]': {'index', 'size'}, 'next[]': {'index'}, 'remove[]': set(), 'reset[]': {'indexCache', 'pageIndex', 'cachedSize'}}, 'MSize': {'getWidth[]': {'width'}, 'getWidthUnit[]': {'widthUnit'}, 'getHeight[]': {'height'}, 'getHeightUnit[]': {'heightUnit'}, "width['float', 'Sizeable']": {'width', 'widthUnit'}, "width['String']": {'width'}, "height['float', 'Sizeable']": {'heightUnit', 'height'}, "height['String']": {'height'}, "size['float', 'Sizeable', 'float', 'Sizeable']": {'heightUnit', 'width', 'widthUnit', 'height'}, "size['String', 'String']": {'width', 'height'}}}
    answer = collectAccessMapFromPath(test_input_path2)
    assert sorted(expected.get('LazyList', {}).get('loadNextPage[]')) == sorted(answer.get('LazyList', {}).get('loadNextPage[]'))

def test3_orika_with_answer1():
    expected = {'MapperBase': {"mapAtoB['A', 'B', 'MappingContext']": set(), "mapBtoA['B', 'A', 'MappingContext']": set(), "setMapperFacade['MapperFacade']": set(), 'getAType[]': set(), 'getBType[]': set(), "setUsedMappers['Mapper']": set(), 'throwShouldNotCalledCustomMapper[]': set()}, 'MapperBaseAdapter': {"mapAtoB['A', 'B', 'MappingContext']": set(), "mapBtoA['B', 'A', 'MappingContext']": set(), "setMapperFacade['MapperFacade']": set()}, 'OrikaSystemProperties': {}, 'MappingContext': {"getConcreteClass['Type', 'Type']": set(), "registerConcreteClass['Type', 'Type']": set(), "cacheMappedObject['S', 'D']": set(), "cacheMappedObject['S', 'Type', 'D']": {'destinationType'}, "isAlreadyMapped['S', 'Type']": {'destinationType'}, "getMappedObject['Object', 'Type']": {'destinationType'}, 'hashCode[]': {'destinationType', 'sourceObject'}, "equals['Object']": {'destinationType', 'sourceObject'}}, 'CacheKey': {'hashCode[]': {'destinationType', 'sourceObject'}, "equals['Object']": {'destinationType', 'sourceObject'}}, 'ConverterException': {}, 'MappingException': {'getLocalizedMessage[]': {'sourceClass', 'sourceType', 'destinationType', 'destinationProperty', 'sourceProperty'}, 'getSourceProperty[]': {'sourceProperty'}, "setSourceProperty['Property']": {'sourceProperty'}, 'getDestinationProperty[]': {'destinationProperty'}, "setDestinationProperty['Property']": {'destinationProperty'}, 'getSourceType[]': {'sourceType'}, "setSourceType['Type']": {'sourceType'}, 'getDestinationType[]': {'destinationType'}, "setDestinationType['Type']": {'destinationType'}, 'getSourceClass[]': {'sourceClass'}, "setSourceClass['Class']": {'sourceClass'}}, 'MapEntry': {'getKey[]': {'key'}, 'getValue[]': {'value'}, "setKey['K']": {'key'}, "setValue['V']": {'value'}, "concreteEntryType['Type']": set(), "entryType['Type']": set(), "entrySet['Map']": set(), 'size[]': set(), 'isEmpty[]': set(), "contains['Object']": set(), 'iterator[]': set(), 'toArray[]': set(), "toArray['T']": set(), "add['MapEntry']": set(), "remove['Object']": set(), "containsAll['Collection']": set(), "addAll['Collection']": set(), "retainAll['Collection']": set(), "removeAll['Collection']": set(), 'clear[]': set(), 'hasNext[]': set(), 'next[]': set(), 'remove[]': set()}, 'MapEntrySet': {'size[]': set(), 'isEmpty[]': set(), "contains['Object']": set(), 'iterator[]': set(), 'toArray[]': set(), "toArray['T']": set(), "add['MapEntry']": set(), "remove['Object']": set(), "containsAll['Collection']": set(), "addAll['Collection']": set(), "retainAll['Collection']": set(), "removeAll['Collection']": set(), 'clear[]': set()}, 'MapEntryIterator': {'hasNext[]': set(), 'next[]': set(), 'remove[]': set()}, 'DefaultFieldMappingConverter': {"suggestMappedField['String', 'Type']": {'delegate'}}, 'CustomConverter': {"canConvert['Type', 'Type']": {'sourceType', 'destinationType'}, "setMapperFacade['MapperFacade']": {'mapperFacade'}, 'toString[]': {'sourceType', 'destinationType'}}, 'CustomMapper': {"mapAtoB['A', 'B', 'MappingContext']": set(), "mapBtoA['B', 'A', 'MappingContext']": set(), "setMapperFacade['MapperFacade']": {'mapperFacade'}, 'getAType[]': {'aType'}, 'getBType[]': {'bType'}, "setUsedMappers['Mapper']": set(), "setUsedTypes['Type']": set(), 'throwShouldNotCalledCustomMapper[]': set()}}
    answer = collectAccessMapFromPath(test_input_path3)

    assert len(answer) == len(expected)
    assert expected.get('DefaultFieldMappingConverter', {}) == answer.get('DefaultFieldMappingConverter', {})

def test4_randoop_with_answer1():
    expected = {'NotExecuted': {'create[]': {'notExecutedSingleton'}, 'toString[]': set(), 'getExecutionTimeNanos[]': set()}, 'SubTypeSet': {'mark[]': {'supportsCheckpoints', 'subTypes', 'types'}, 'undoLastStep[]': {'supportsCheckpoints', 'subTypes', 'types'}, "add['Type']": set(), "addQueryType['Type']": {'types'}, "getMatches['Type']": set(), 'size[]': set()}, 'MultiVisitor': {"createMultiVisitor['List']": {'visitors'}, "initialize['ExecutableSequence']": {'visitors'}, "visitAfterStatement['ExecutableSequence', 'int']": {'visitors'}, "visitBeforeStatement['ExecutableSequence', 'int']": {'visitors'}, "visitAfterSequence['ExecutableSequence']": {'visitors'}}, 'ReplayFailureException': {'getDecoration[]': {'decoration'}}, 'NormalExecution': {'getRuntimeValue[]': {'result'}, 'toString[]': {'result'}}, 'ExceptionalExecution': {'getException[]': {'exception'}, 'toString[]': set()}, 'ExecutionOutcome': {'getExecutionTimeNanos[]': {'executionTimeNanos'}, "set_output['String']": {'output'}, 'get_output[]': {'output'}}, 'Globals': {"write['int']": set(), 'getRandoopVersion[]': {'RANDOOP_VERSION'}, 'getClassPath[]': set()}, 'NullOutputStream': {"write['int']": set()}, 'DummyVisitor': {"initialize['ExecutableSequence']": set(), "visitBeforeStatement['ExecutableSequence', 'int']": set(), "visitAfterStatement['ExecutableSequence', 'int']": set(), "visitAfterSequence['ExecutableSequence']": set()}}
    answer = collectAccessMapFromPath(test_input_path4)
    assert expected.get('NotExecuted', {}).items() == answer.get('NotExecuted', {}).items()

def test5_lightcouch_with_answer1():
    expected = {'Page': {'isHasPrevious[]': {'isHasPrevious'}, 'isHasNext[]': {'isHasNext'}, 'getResultList[]': {'resultList'}, 'getTotalResults[]': {'totalResults'}, 'getResultFrom[]': {'resultFrom'}, 'getResultTo[]': {'resultTo'}, 'getPageNumber[]': {'pageNumber'}, 'getNextParam[]': {'nextParam'}, 'getPreviousParam[]': {'previousParam'}, "setHasPrevious['boolean']": {'isHasPrevious'}, "setHasNext['boolean']": {'isHasNext'}, "setResultList['List']": {'resultList'}, "setTotalResults['long']": {'totalResults'}, "setResultFrom['int']": {'resultFrom'}, "setResultTo['int']": {'resultTo'}, "setPageNumber['int']": {'pageNumber'}, "setNextParam['String']": {'nextParam'}, "setPreviousParam['String']": {'previousParam'}}, 'DocumentConflictException': {}, 'Response': {'getId[]': {'id'}, 'getRev[]': {'rev'}, 'getError[]': {'error'}, 'getReason[]': {'reason'}, 'toString[]': {'rev', 'id'}}, 'Replicator': {'save[]': {'dbURI', 'userCtxRoles', 'userCtxName', 'replicatorDoc'}, 'find[]': {'dbURI'}, 'findAll[]': {'dbURI'}, 'remove[]': {'dbURI'}, "source['String']": set(), "target['String']": set(), "continuous['boolean']": set(), "filter['String']": set(), "queryParams['String']": set(), "queryParams['Map']": set(), "docIds['String']": set(), "proxy['String']": set(), "createTarget['Boolean']": set(), "replicatorDB['String']": {'dbURI', 'replicatorDB'}, "replicatorDocId['String']": set(), "replicatorDocRev['String']": set(), "workerProcesses['int']": set(), "workerBatchSize['int']": set(), "httpConnections['int']": set(), "connectionTimeout['long']": set(), "retriesPerRequest['int']": set(), "userCtxName['String']": {'userCtxName'}, "userCtxRoles['String']": {'userCtxRoles'}, "sinceSeq['String']": set()}, 'Changes': {'continuousChanges[]': {'httpGet'}, 'hasNext[]': set(), 'next[]': set(), 'stop[]': {'stop'}, 'getChanges[]': set(), "since['String']": set(), "limit['int']": set(), "heartBeat['long']": set(), "timeout['long']": set(), "filter['String']": set(), "includeDocs['boolean']": set(), "style['String']": set(), 'readNextRow[]': {'stop'}, 'getReader[]': {'reader'}, "setReader['BufferedReader']": {'reader'}, 'getNextRow[]': {'nextRow'}, "setNextRow['Row']": {'nextRow'}, 'terminate[]': set()}, 'CouchDbContext': {"deleteDB['String', 'String']": set(), "createDB['String']": set(), 'getAllDbs[]': set(), 'info[]': set(), 'serverVersion[]': set(), 'compact[]': set(), 'ensureFullCommit[]': set(), "uuids['long']": set()}, 'CouchDbConfig': {'readProperties[]': {'dbProperties', 'properties'}, 'getProperties[]': {'dbProperties'}, "getProperty['String', 'boolean']": {'configFile'}, "getPropertyAsInt['String', 'boolean']": set()}, 'Document': {'getId[]': {'id'}, 'getRevision[]': {'revision'}, 'getAttachments[]': {'attachments'}, "setId['String']": {'id'}, "setRevision['String']": {'revision'}, "setAttachments['Map']": {'attachments'}, "addAttachment['String', 'Attachment']": {'attachments'}, 'hashCode[]': {'id'}, "equals['Object']": {'id'}}, 'ReplicatorDocument': {'getSource[]': {'source'}, 'getTarget[]': {'target'}, 'getContinuous[]': {'continuous'}, 'getFilter[]': {'filter'}, 'getQueryParams[]': {'queryParams'}, 'getDocIds[]': {'docIds'}, 'getProxy[]': {'proxy'}, 'getCreateTarget[]': {'createTarget'}, 'getReplicationId[]': {'replicationId'}, 'getReplicationState[]': {'replicationState'}, 'getReplicationStateTime[]': {'replicationStateTime'}, 'getUserCtx[]': {'userCtx'}, 'getWorkerProcesses[]': {'workerProcesses'}, 'getWorkerBatchSize[]': {'workerBatchSize'}, 'getHttpConnections[]': {'httpConnections'}, 'getConnectionTimeout[]': {'connectionTimeout'}, 'getRetriesPerRequest[]': {'retriesPerRequest'}, "setSource['String']": {'source'}, "setTarget['String']": {'target'}, "setContinuous['Boolean']": {'continuous'}, "setFilter['String']": {'filter'}, "setQueryParams['JsonObject']": {'queryParams'}, "setDocIds['String']": {'docIds'}, "setProxy['String']": {'proxy'}, "setCreateTarget['Boolean']": {'createTarget'}, "setReplicationId['String']": {'replicationId'}, "setReplicationState['String']": {'replicationState'}, "setReplicationStateTime['String']": {'replicationStateTime'}, "setUserCtx['UserCtx']": {'userCtx'}, "setWorkerProcesses['Integer']": {'workerProcesses'}, "setWorkerBatchSize['Integer']": {'workerBatchSize'}, "setHttpConnections['Integer']": {'httpConnections'}, "setConnectionTimeout['Long']": {'connectionTimeout'}, "setRetriesPerRequest['Integer']": {'retriesPerRequest'}, 'getSinceSeq[]': {'sinceSeq'}, "setSinceSeq['String']": {'sinceSeq'}, 'getName[]': {'name'}, 'getRoles[]': {'roles'}, "setName['String']": {'name'}, "setRoles['String']": {'roles'}}, 'UserCtx': {'getName[]': {'name'}, 'getRoles[]': {'roles'}, "setName['String']": {'name'}, "setRoles['String']": {'roles'}}, 'DesignDocument': {'getLanguage[]': {'language'}, 'getViews[]': {'views'}, 'getValidateDocUpdate[]': {'validateDocUpdate'}, 'getRewrites[]': {'rewrites'}, 'getFulltext[]': {'fulltext'}, 'getIndexes[]': {'indexes'}, 'getFilters[]': {'filters'}, 'getShows[]': {'shows'}, 'getLists[]': {'lists'}, 'getUpdates[]': {'updates'}, "setLanguage['String']": {'language'}, "setViews['Map']": {'views'}, "setValidateDocUpdate['String']": {'validateDocUpdate'}, "setRewrites['JsonArray']": {'rewrites'}, "setFulltext['JsonObject']": {'fulltext'}, "setIndexes['JsonObject']": {'indexes'}, "setFilters['Map']": {'filters'}, "setShows['Map']": {'shows'}, "setLists['Map']": {'lists'}, "setUpdates['Map']": {'updates'}, 'hashCode[]': {'map', 'reduce'}, "equals['Object']": {'map', 'reduce'}, 'getMap[]': {'map'}, 'getReduce[]': {'reduce'}, "setMap['String']": {'map'}, "setReduce['String']": {'reduce'}}, 'MapReduce': {'getMap[]': {'map'}, 'getReduce[]': {'reduce'}, "setMap['String']": {'map'}, "setReduce['String']": {'reduce'}, 'hashCode[]': {'map', 'reduce'}, "equals['Object']": {'map', 'reduce'}}, 'NoDocumentException': {}, 'Params': {'revsInfo[]': set(), 'attachments[]': set(), 'revisions[]': set(), "rev['String']": set(), 'conflicts[]': set(), 'localSeq[]': set(), "addParam['String', 'String']": set(), 'getParams[]': {'params'}}, 'CouchDbClientAndroid': {"createHttpClient['CouchDbProperties']": set(), 'createContext[]': set(), 'shutdown[]': set(), "createRegistry['CouchDbProperties']": set(), "registerInterceptors['DefaultHttpClient']": set(), "process['HttpRequest', 'HttpContext']": set(), "process['HttpResponse', 'HttpContext']": set(), "checkClientTrusted['X509Certificate', 'String']": set(), "checkServerTrusted['X509Certificate', 'String']": set(), 'getAcceptedIssuers[]': set(), "createSocket['Socket', 'String', 'int', 'boolean']": set(), 'createSocket[]': set()}, 'MySSLSocketFactory': {"checkClientTrusted['X509Certificate', 'String']": set(), "checkServerTrusted['X509Certificate', 'String']": set(), 'getAcceptedIssuers[]': set(), "createSocket['Socket', 'String', 'int', 'boolean']": set(), 'createSocket[]': set()}, 'PreemptiveAuthInterceptor': {"process['HttpRequest', 'HttpContext']": set()}, 'CouchDbProperties': {'getDbName[]': {'dbName'}, 'isCreateDbIfNotExist[]': {'createDbIfNotExist'}, 'getProtocol[]': {'protocol'}, 'getHost[]': {'host'}, 'getPath[]': {'path'}, 'getPort[]': {'port'}, 'getUsername[]': {'username'}, 'getPassword[]': {'password'}, 'getSocketTimeout[]': {'socketTimeout'}, 'getConnectionTimeout[]': {'connectionTimeout'}, 'getMaxConnections[]': {'maxConnections'}, 'getProxyHost[]': {'proxyHost'}, 'getProxyPort[]': {'proxyPort'}, "setDbName['String']": {'dbName'}, "setCreateDbIfNotExist['boolean']": {'createDbIfNotExist'}, "setProtocol['String']": {'protocol'}, "setHost['String']": {'host'}, "setPath['String']": {'path'}, "setPort['int']": {'port'}, "setUsername['String']": {'username'}, "setPassword['String']": {'password'}, "setSocketTimeout['int']": {'socketTimeout'}, "setConnectionTimeout['int']": {'connectionTimeout'}, "setMaxConnections['int']": {'maxConnections'}, "setProxyHost['String']": {'proxyHost'}, "setProxyPort['int']": {'proxyPort'}, 'clearPassword[]': set()}, 'ViewResult': {'getTotalRows[]': {'totalRows'}, 'getUpdateSeq[]': {'updateSeq'}, 'getOffset[]': {'offset'}, 'getRows[]': {'rows'}, "setTotalRows['long']": {'totalRows'}, "setUpdateSeq['String']": {'updateSeq'}, "setOffset['int']": {'offset'}, "setRows['List']": {'rows'}, 'toString[]': {'id'}, 'getId[]': {'id'}, 'getKey[]': {'key'}, 'getValue[]': {'value'}, 'getDoc[]': {'doc'}, "setId['String']": {'id'}, "setKey['K']": {'key'}, "setValue['V']": {'value'}, "setDoc['T']": {'doc'}}, 'Rows': {'getId[]': {'id'}, 'getKey[]': {'key'}, 'getValue[]': {'value'}, 'getDoc[]': {'doc'}, "setId['String']": {'id'}, "setKey['K']": {'key'}, "setValue['V']": {'value'}, "setDoc['T']": {'doc'}, 'toString[]': {'id'}}, 'View': {'queryForStream[]': {'allDocsKeys'}, "query['Class']": {'includeDocs', 'gson'}, "queryView['Class', 'Class', 'Class']": {'includeDocs', 'gson'}, 'queryForString[]': set(), 'queryForInt[]': set(), 'queryForLong[]': set(), 'queryForBoolean[]': set(), "queryValue['Class']": {'gson'}, "queryPage['int', 'String', 'Class']": {'CURRENT_START_KEY', 'START_KEY_DOC_ID', 'CURRENT_START_KEY_DOC_ID', 'startKey', 'ACTION', 'CURRENT_KEYS', 'START_KEY', 'startKeyDocId'}, "queryNextPage['int', 'String', 'String', 'String', 'String', 'Class']": {'CURRENT_START_KEY', 'START_KEY_DOC_ID', 'CURRENT_START_KEY_DOC_ID', 'startKey', 'ACTION', 'CURRENT_KEYS', 'PREVIOUS', 'START_KEY', 'NEXT', 'startKeyDocId'}, "queryPreviousPage['int', 'String', 'String', 'String', 'String', 'Class']": {'CURRENT_START_KEY', 'START_KEY_DOC_ID', 'CURRENT_START_KEY_DOC_ID', 'ACTION', 'CURRENT_KEYS', 'PREVIOUS', 'START_KEY', 'NEXT'}, "key['Object']": {'key'}, "startKey['Object']": {'startKey'}, "startKeyDocId['String']": {'startKeyDocId'}, "endKey['Object']": {'endKey'}, "endKeyDocId['String']": {'endKeyDocId'}, "limit['Integer']": {'limit'}, "stale['String']": {'stale'}, "descending['Boolean']": {'descending'}, "skip['Integer']": {'skip'}, "group['Boolean']": {'group'}, "groupLevel['Integer']": {'groupLevel'}, "reduce['Boolean']": {'reduce'}, "includeDocs['Boolean']": {'includeDocs'}, "inclusiveEnd['Boolean']": {'inclusiveEnd'}, "updateSeq['Boolean']": {'updateSeq'}, "keys['List']": {'allDocsKeys'}, "getKeyAsJson['Object']": {'key'}}, 'CouchDbInfo': {'getDbName[]': {'dbName'}, 'getDocCount[]': {'docCount'}, 'getDocDelCount[]': {'docDelCount'}, 'getUpdateSeq[]': {'updateSeq'}, 'getPurgeSeq[]': {'purgeSeq'}, 'isCompactRunning[]': {'compactRunning'}, 'getDiskSize[]': {'diskSize'}, 'getInstanceStartTime[]': {'instanceStartTime'}, 'getDiskFormatVersion[]': {'diskFormatVersion'}, 'toString[]': {'instanceStartTime', 'diskFormatVersion', 'compactRunning', 'diskSize', 'updateSeq', 'dbName', 'docDelCount', 'docCount', 'purgeSeq'}}, 'Attachment': {'getData[]': {'data'}, 'getContentType[]': {'contentType'}, 'getRevpos[]': {'revpos'}, 'getDigest[]': {'digest'}, 'getLength[]': {'length'}, 'isStub[]': {'stub'}, "setContentType['String']": {'contentType'}, "setData['String']": {'data'}}, 'ReplicationResult': {'isOk[]': {'ok'}, 'getSessionId[]': {'sessionId'}, 'getSourceLastSeq[]': {'sourceLastSeq'}, 'getLocalId[]': {'localId'}, 'getHistories[]': {'histories'}, 'getStartTime[]': {'startTime'}, 'getEndTime[]': {'endTime'}, 'getStartLastSeq[]': {'startLastSeq'}, 'getEndLastSeq[]': {'endLastSeq'}, 'getRecordedSeq[]': {'recordedSeq'}, 'getMissingChecked[]': {'missingChecked'}, 'getMissingFound[]': {'missingFound'}, 'getDocsRead[]': {'docsRead'}, 'getDocsWritten[]': {'docsWritten'}, 'getDocWriteFailures[]': {'docWriteFailures'}}, 'ReplicationHistory': {'getSessionId[]': {'sessionId'}, 'getStartTime[]': {'startTime'}, 'getEndTime[]': {'endTime'}, 'getStartLastSeq[]': {'startLastSeq'}, 'getEndLastSeq[]': {'endLastSeq'}, 'getRecordedSeq[]': {'recordedSeq'}, 'getMissingChecked[]': {'missingChecked'}, 'getMissingFound[]': {'missingFound'}, 'getDocsRead[]': {'docsRead'}, 'getDocsWritten[]': {'docsWritten'}, 'getDocWriteFailures[]': {'docWriteFailures'}}, 'CouchDbDesign': {"synchronizeWithDb['DesignDocument']": set(), 'synchronizeAllWithDb[]': set(), "getFromDb['String']": set(), "getFromDb['String', 'String']": set(), 'getAllFromDesk[]': {'DESIGN_DOCS_DIR'}, "getFromDesk['String']": {'FILTERS', 'FULLTEXT', 'LISTS', 'VALIDATE_DOC', 'VIEWS', 'REWRITES', 'UPDATES', 'DESIGN_DOCS_DIR', 'JAVASCRIPT', 'DESIGN_PREFIX', 'INDEXES', 'SHOWS'}, "populateMap['String', 'List', 'String']": set(), "readContent['List', 'String', 'String']": set()}, 'CouchDbClient': {"createHttpClient['CouchDbProperties']": set(), 'createContext[]': set(), "createConnectionManager['CouchDbProperties', 'Registry']": set(), "createRegistry['CouchDbProperties']": set(), "isTrusted['X509Certificate', 'String']": set(), "registerInterceptors['HttpClientBuilder']": set(), "process['HttpRequest', 'HttpContext']": set(), "process['HttpResponse', 'HttpContext']": set(), 'shutdown[]': set(), 'close[]': set()}, 'Replication': {'trigger[]': {'target', 'source'}, "source['String']": {'source'}, "target['String']": {'target'}, "continuous['Boolean']": {'continuous'}, "filter['String']": {'filter'}, "queryParams['String']": {'queryParams'}, "queryParams['Map']": {'queryParams'}, "docIds['String']": {'docIds'}, "proxy['String']": {'proxy'}, "cancel['Boolean']": {'cancel'}, "createTarget['Boolean']": {'createTarget'}, "sinceSeq['String']": {'sinceSeq'}, "targetOauth['String', 'String', 'String', 'String']": {'consumerKey', 'token', 'tokenSecret', 'targetOauth', 'consumerSecret'}, 'createJson[]': {'sinceSeq', 'createTarget', 'docIds', 'consumerKey', 'filter', 'token', 'tokenSecret', 'continuous', 'targetOauth', 'source', 'queryParams', 'target', 'cancel', 'consumerSecret', 'proxy'}, "addProperty['JsonObject', 'String', 'Object']": set()}, 'CouchDbClientBase': {"createHttpClient['CouchDbProperties']": set(), 'createContext[]': set(), 'shutdown[]': set(), 'context[]': {'context'}, 'design[]': {'design'}, "view['String']": set(), 'replication[]': set(), 'replicator[]': set(), 'changes[]': set(), "find['Class', 'String']": set(), "find['Class', 'String', 'Params']": set(), "find['Class', 'String', 'String']": set(), "findAny['Class', 'String']": set(), "find['String']": set(), "find['String', 'String']": set(), "findDocs['String', 'Class']": {'gson'}, "contains['String']": set(), "save['Object']": set(), "post['Object']": set(), "batch['Object']": set(), "update['Object']": set(), "remove['Object']": set(), "remove['String', 'String']": set(), "bulk['List', 'boolean']": set(), "saveAttachment['InputStream', 'String', 'String']": set(), "saveAttachment['InputStream', 'String', 'String', 'String', 'String']": set(), "invokeUpdateHandler['String', 'String', 'Params']": set(), "executeRequest['HttpRequestBase']": {'host'}, 'syncDesignDocsWithDb[]': set(), "setGsonBuilder['GsonBuilder']": {'gson'}, 'getBaseUri[]': {'baseURI'}, 'getDBUri[]': {'dbURI'}, 'getGson[]': {'gson'}, "get['HttpGet']": set(), "get['URI']": set(), "get['URI', 'Class']": set(), "head['URI']": set(), "put['URI', 'Object', 'boolean']": set(), "put['URI', 'InputStream', 'String']": set(), "post['URI', 'String']": set(), "delete['URI']": set(), "validate['HttpResponse']": set(), "getResponse['HttpResponse']": set(), "getResponseList['HttpResponse']": set(), "setEntity['HttpEntityEnclosingRequestBase', 'String']": set(), "initGson['GsonBuilder']": set(), "deserialize['JsonElement', 'Type', 'JsonDeserializationContext']": set(), "serialize['JsonObject', 'Type', 'JsonSerializationContext']": set()}, 'CouchDbUtil': {"assertNotEmpty['Object', 'String']": set(), "assertNull['Object', 'String']": set(), 'generateUUID[]': set(), "JsonToObject['Gson', 'JsonElement', 'String', 'Class']": set(), "getAsString['JsonObject', 'String']": set(), "getAsLong['JsonObject', 'String']": set(), "getAsInt['JsonObject', 'String']": set(), "listResources['String']": {'SPRING_BOOT_DIR'}, "readFile['String']": {'LINE_SEP'}, "getStream['HttpResponse']": set(), "removeExtension['String']": set(), "streamToString['InputStream']": set(), "close['HttpResponse']": set(), "close['Closeable']": set()}, 'CouchDbException': {}, 'URIBuilder': {'buildUri[]': set(), "buildUri['URI']": set(), "scheme['String']": {'scheme'}, "host['String']": {'host'}, "port['int']": {'port'}, "path['String']": {'path'}, "pathEncoded['String']": {'path'}, "query['String', 'Object']": {'params'}, "query['Params']": {'params'}, 'build[]': {'scheme', 'host', 'port', 'path'}}, 'ChangesResult': {'getResults[]': {'results'}, 'getLastSeq[]': {'lastSeq'}, 'getSeq[]': {'seq'}, 'getId[]': {'id'}, 'getChanges[]': {'changes'}, 'isDeleted[]': {'deleted'}, 'getDoc[]': {'doc'}, 'getRev[]': {'rev'}}, 'Row': {'getSeq[]': {'seq'}, 'getId[]': {'id'}, 'getChanges[]': {'changes'}, 'isDeleted[]': {'deleted'}, 'getDoc[]': {'doc'}, 'getRev[]': {'rev'}}, 'Rev': {'getRev[]': {'rev'}}}
    answer = collectAccessMapFromPath(test_input_path5)
    assert list(expected.values())[0].pop("setResultTo['int']") == list(answer.values())[0].pop("setResultTo['int']")